# frozen_string_literal: true

ENV['TZ'] ||= 'UTC'
ENV['RAILS_ENV'] ||= 'test'
ENV['OPENAPI_OUTPUT'] ||= 'yaml'

require File.expand_path('../apps/rails/config/environment', __dir__)
require 'rspec/rails'

RSpec::OpenAPI.title = 'OpenAPI Documentation'
RSpec::OpenAPI.request_headers = %w[X-Authorization-Token Secret-Key]
RSpec::OpenAPI.response_headers = %w[X-Cursor]
RSpec::OpenAPI.path = File.expand_path("../apps/rails/doc/rspec_openapi.#{ENV.fetch('OPENAPI_OUTPUT', nil)}", __dir__)
RSpec::OpenAPI.ignored_paths = ['/admin/masters/extensions']
RSpec::OpenAPI.comment = <<~COMMENT
  This file is auto-generated by rspec-openapi https://github.com/k0kubun/rspec-openapi

  When you write a spec in spec/requests, running the spec with `OPENAPI=1 rspec` will
  update this file automatically. You can also manually edit this file.
COMMENT
RSpec::OpenAPI.servers = [{ url: 'http://localhost:3000' }]
RSpec::OpenAPI.info = {
  description: 'My beautiful API',
  license: {
    name: 'Apache 2.0',
    url: 'https://www.apache.org/licenses/LICENSE-2.0.html',
  },
}

RSpec::OpenAPI.formats_builder = ->(_example, key) { key.end_with?('_at') ? 'date-time' : nil }

RSpec::OpenAPI.security_schemes = {
  SecretApiKeyAuth: {
    type: 'apiKey',
    in: 'header',
    name: 'Secret-Key',
  },
}

RSpec.describe 'Tables', type: :request do
  describe '#index', openapi: { summary: 'Get a list of tables' } do
    context 'returns a list of tables' do
      it 'with flat query parameters' do
        get '/tables', params: { page: '1', per: '10' },
                       headers: { authorization: 'k0kubun', 'X-Authorization-Token': 'token' }
        expect(response.status).to eq(200)
      end

      it 'with deep query parameters' do
        get '/tables', params: { filter: { 'name' => 'Example Table' } }, headers: { authorization: 'k0kubun' }
        expect(response.status).to eq(200)
      end

      it 'with different deep query parameters' do
        get '/tables', params: { filter: { 'price' => 0 } }, headers: { authorization: 'k0kubun' }
        expect(response.status).to eq(200)
      end
    end

    it 'has a request spec which does not make any request' do
      expect(request).to eq(nil)
    end

    it 'does not return tables if unauthorized' do
      get '/tables'
      expect(response.status).to eq(401)
    end
  end

  describe '#show' do
    it 'returns a table' do
      get '/tables/1', headers: { authorization: 'k0kubun' }
      expect(response.status).to eq(200)
    end

    it 'does not return a table if unauthorized' do
      get '/tables/1'
      expect(response.status).to eq(401)
    end

    it 'does not return a table if not found' do
      get '/tables/2', headers: { authorization: 'k0kubun' }
      expect(response.status).to eq(404)
    end

    it 'does not return a table if not found (openapi: false)', openapi: false do
      get '/tables/3', headers: { authorization: 'k0kubun' }
      expect(response.status).to eq(404)
    end
  end

  describe '#create' do
    it 'returns a table' do
      post '/tables', headers: { authorization: 'k0kubun', 'Content-Type': 'application/json' }, params: {
        name: 'k0kubun',
        description: 'description',
        database_id: 2,
      }.to_json
      expect(response.status).to eq(201)
    end

    it 'fails to create a table' do
      post '/tables', headers: { authorization: 'k0kubun', 'Content-Type': 'application/json' }, params: {
        description: 'description',
        database_id: 2,
      }.to_json
      expect(response.status).to eq(422)
    end

    it 'fails to create a table (2)' do
      post '/tables', headers: { authorization: 'k0kubun', 'Content-Type': 'application/json' }, params: {
        name: 'some_invalid_name',
        description: 'description',
        database_id: 2,
      }.to_json
      expect(response.status).to eq(422)
    end
  end

  describe '#update', openapi: { example_mode: :multiple } do
    it 'returns a table' do
      patch '/tables/1', headers: { authorization: 'k0kubun' }, params: { name: 'test' }
      expect(response.status).to eq(200)
    end

    it 'returns a table via a UUID' do
      patch '/tables/abc-123', headers: { authorization: 'k0kubun' }, params: { name: 'test' }
      expect(response.status).to eq(200)
    end
  end

  describe '#destroy' do
    it 'returns a table' do
      delete '/tables/1', headers: { authorization: 'k0kubun' }
      expect(response.status).to eq(200)
    end

    it 'returns no content if specified' do
      delete '/tables/1', headers: { authorization: 'k0kubun' }, params: { no_content: true }
      expect(response.status).to eq(202)
    end
  end
end

RSpec.describe 'Images', type: :request do
  describe '#payload' do
    it 'returns a image payload' do
      get '/images/1'
      expect(response.status).to eq(200)
    end
  end

  describe '#index' do
    it 'can return an object with an attribute of empty array' do
      get '/images'
      expect(response.status).to eq(200)
    end
  end

  describe '#upload' do
    before do
      png = 'iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAAAAADhZOFXAAAADklEQVQIW2P4DwUMlDEA98A/wTjP
      QBoAAAAASUVORK5CYII='.unpack1('m')
      File.binwrite('test.png', png)
    end
    let(:image) { Rack::Test::UploadedFile.new('test.png', 'image/png') }

    it 'returns a image payload with upload' do
      post '/images/upload', params: { image: image }
      expect(response.status).to eq(200)
    end
  end

  describe '#upload_nested' do
    before do
      png = 'iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAAAAADhZOFXAAAADklEQVQIW2P4DwUMlDEA98A/wTjP
      QBoAAAAASUVORK5CYII='.unpack1('m')
      File.binwrite('test.png', png)
    end
    let(:image) { Rack::Test::UploadedFile.new('test.png', 'image/png') }

    it 'returns a image payload with upload nested' do
      post '/images/upload_nested', params: { nested_image: { image: image, caption: 'Some caption' } }
      expect(response.status).to eq(200)
    end
  end

  describe '#upload_multiple' do
    before do
      png = 'iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAAAAADhZOFXAAAADklEQVQIW2P4DwUMlDEA98A/wTjP
      QBoAAAAASUVORK5CYII='.unpack1('m')
      File.binwrite('test.png', png)
    end
    let(:image) { Rack::Test::UploadedFile.new('test.png', 'image/png') }

    it 'returns a image payload with upload multiple' do
      post '/images/upload_multiple', params: { images: [image, image] }
      expect(response.status).to eq(200)
    end
  end

  describe '#upload_multiple_nested' do
    before do
      png = 'iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAAAAADhZOFXAAAADklEQVQIW2P4DwUMlDEA98A/wTjP
      QBoAAAAASUVORK5CYII='.unpack1('m')
      File.binwrite('test.png', png)
    end
    let(:image) { Rack::Test::UploadedFile.new('test.png', 'image/png') }

    it 'returns a image payload with upload multiple nested' do
      post '/images/upload_multiple_nested', params: { images: [{ image: image }, { image: image }] }
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'SecretKey securityScheme',
               type: :request,
               openapi: { security: [{ 'SecretApiKeyAuth' => [] }] } do
  describe '#secret_items' do
    it 'authorizes with secret key' do
      get '/secret_items',
          headers: {
            'Secret-Key' => '42',
          }
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'Extra routes', type: :request do
  describe '#test_block', openapi: { deprecated: true } do
    it 'returns the block content' do
      get '/test_block'
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'Engine test', type: :request do
  describe 'engine routes' do
    it 'returns some content from the engine' do
      get '/my_engine/eng_route'
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'Engine extra routes', type: :request do
  describe '#test' do
    it 'returns the block content' do
      get '/my_engine/test'
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'Additional Properties test', type: :request do
  describe '#test' do
    it 'returns some content' do
      get '/additional_properties'
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'Namespace test', type: :request do
  describe '/admin/masters/extensions' do
    it 'returns some content' do
      get '/admin/masters/extensions'
      expect(response.status).to eq(200)
    end

    it 'creates a content' do
      post '/admin/masters/extensions'
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'Rack app test', type: :request do
  describe '/rack/foo' do
    it 'returns some content foo' do
      get '/rack/foo'
      expect(response.status).to eq(200)
    end
  end

  describe '/rack/bar' do
    it 'returns some content bar' do
      get '/rack/bar'
      expect(response.status).to eq(200)
    end
  end
end

RSpec.describe 'non-numeric path parameter', type: :request do
  it 'finds a site' do
    get '/sites/abc123', as: :json
    expect(response.status).to eq(200)
  end

  it 'raises not found' do
    get '/sites/no-such', as: :json
    expect(response.status).to eq(404)
  end
end

RSpec.describe 'Array of hashes', type: :request do
  describe ' with nullable keys' do
    it 'returns some content' do
      get '/array_hashes/nullable'
      expect(response.status).to eq(200)
    end
  end

  describe 'with non-nullable keys' do
    it 'returns some content' do
      get '/array_hashes/non_nullable'
      expect(response.status).to eq(200)
    end
  end

  describe 'with nested keys with type conflicts' do
    it 'returns some content' do
      get '/array_hashes/nested'
      expect(response.status).to eq(200)
    end
  end

  describe 'with empty array' do
    it 'returns empty items' do
      get '/array_hashes/empty_array'
      expect(response.status).to eq(200)
    end
  end

  describe 'with single item' do
    it 'returns single item' do
      get '/array_hashes/single_item'
      expect(response.status).to eq(200)
    end
  end

  describe 'with non-hash items' do
    it 'returns array of strings' do
      get '/array_hashes/non_hash_items'
      expect(response.status).to eq(200)
    end
  end

  describe 'with nested arrays' do
    it 'returns items with array properties' do
      get '/array_hashes/nested_arrays'
      expect(response.status).to eq(200)
    end
  end

  describe 'with nested objects' do
    it 'returns items with object properties' do
      get '/array_hashes/nested_objects'
      expect(response.status).to eq(200)
    end
  end

  describe 'with mixed types in nested objects' do
    it 'returns items with type conflicts in nested properties' do
      get '/array_hashes/mixed_types_nested'
      expect(response.status).to eq(200)
    end
  end

  describe 'with mixed types in nested objects in nested array' do
    it 'returns items that would produce different oneOf types' do
      get '/array_hashes/multiple_one_of_test'
      expect(response.status).to eq(200)
    end
  end
end

# Tests for example_mode feature

# Test :none mode - should generate only schema, no examples
RSpec.describe 'example_mode :none', type: :request do
  describe 'GET /example_mode_none', openapi: { example_mode: :none } do
    it 'generates schema without example' do
      get '/example_mode_none'
      expect(response.status).to eq(200)
    end
  end
end

# Test :single mode (default) - should generate single example
RSpec.describe 'example_mode :single', type: :request do
  describe 'GET /example_mode_single' do
    it 'generates schema with single example' do
      get '/example_mode_single'
      expect(response.status).to eq(200)
    end
  end
end

# Test :multiple mode - should generate named examples
RSpec.describe 'example_mode :multiple', type: :request do
  describe 'GET /example_mode_multiple', openapi: { example_mode: :multiple } do
    it 'first example' do
      get '/example_mode_multiple'
      expect(response.status).to eq(200)
    end

    it 'second example' do
      get '/example_mode_multiple'
      expect(response.status).to eq(200)
    end
  end
end

# Test inheritance - parent sets :multiple, children inherit
RSpec.describe 'example_mode inheritance', type: :request, openapi: { example_mode: :multiple } do
  describe 'GET /example_mode_inherit' do
    it 'inherits multiple from parent' do
      get '/example_mode_inherit'
      expect(response.status).to eq(200)
    end

    it 'also inherits multiple from parent' do
      get '/example_mode_inherit'
      expect(response.status).to eq(200)
    end
  end

  # Test override to :single within :multiple context
  describe 'GET /example_mode_override_single', openapi: { example_mode: :single } do
    it 'overrides to single' do
      get '/example_mode_override_single'
      expect(response.status).to eq(200)
    end
  end

  # Test override to :none within :multiple context
  describe 'GET /example_mode_override_none', openapi: { example_mode: :none } do
    it 'overrides to none' do
      get '/example_mode_override_none'
      expect(response.status).to eq(200)
    end
  end
end

# Test mixed example modes on same endpoint (merger conversion test)
RSpec.describe 'example_mode mixed', type: :request do
  describe 'GET /example_mode_mixed' do
    it 'first with single mode' do
      get '/example_mode_mixed'
      expect(response.status).to eq(200)
    end

    context 'with multiple', openapi: { example_mode: :multiple } do
      it 'second with multiple mode' do
        get '/example_mode_mixed'
        expect(response.status).to eq(200)
      end
    end
  end
end

# Test global enable_example = false overrides example_mode
RSpec.describe 'example_mode disabled globally', type: :request do
  before(:context) do
    @original_enable_example = RSpec::OpenAPI.enable_example
    RSpec::OpenAPI.enable_example = false
  end

  after(:context) do
    RSpec::OpenAPI.enable_example = @original_enable_example
  end

  describe 'GET /example_mode_disabled' do
    it 'does not generate examples for default mode' do
      get '/example_mode_disabled'
      expect(response.status).to eq(200)
    end
  end

  describe 'GET /example_mode_disabled_single', openapi: { example_mode: :single } do
    it 'does not generate examples for single mode' do
      get '/example_mode_disabled_single'
      expect(response.status).to eq(200)
    end
  end

  describe 'GET /example_mode_disabled_multiple', openapi: { example_mode: :multiple } do
    it 'does not generate examples for multiple mode' do
      get '/example_mode_disabled_multiple'
      expect(response.status).to eq(200)
    end
  end

  describe 'GET /example_mode_disabled_none', openapi: { example_mode: :none } do
    it 'does not generate examples for none mode' do
      get '/example_mode_disabled_none'
      expect(response.status).to eq(200)
    end
  end
end

# Test request body with array of primitive values
RSpec.describe 'Tags with array params', type: :request do
  describe '#create' do
    it 'creates tags with array of strings' do
      post '/tags', params: { names: %w[ruby rails rspec], priority: 1 }.to_json,
                    headers: { 'CONTENT_TYPE' => 'application/json' }
      expect(response.status).to eq(201)
    end
  end
end

# Test custom example_key override
RSpec.describe 'Custom example_key', type: :request do
  describe 'GET /custom_example_key', openapi: { example_mode: :multiple, example_key: 'my_custom_key' } do
    it 'uses custom example key instead of description' do
      get '/custom_example_key'
      expect(response.status).to eq(200)
    end
  end
end

# Test custom example_name override
RSpec.describe 'Custom example_name', type: :request do
  describe 'GET /custom_example_name', openapi: { example_mode: :multiple, example_name: 'My Custom Name' } do
    it 'uses custom example name for summary' do
      get '/custom_example_name'
      expect(response.status).to eq(200)
    end
  end
end

# Test enable_example_summary = false
RSpec.describe 'Example summary disabled', type: :request do
  before(:context) do
    @original_enable_example_summary = RSpec::OpenAPI.enable_example_summary
    RSpec::OpenAPI.enable_example_summary = false
  end

  after(:context) do
    RSpec::OpenAPI.enable_example_summary = @original_enable_example_summary
  end

  describe 'GET /example_summary_disabled', openapi: { example_mode: :multiple } do
    it 'generates examples without summary' do
      get '/example_summary_disabled'
      expect(response.status).to eq(200)
    end
  end
end

# Test empty example_name (triggers nil summary path)
RSpec.describe 'Empty example_name', type: :request do
  describe 'GET /empty_example_name', openapi: { example_mode: :multiple, example_name: '' } do
    it 'handles empty example_name' do
      get '/empty_example_name'
      expect(response.status).to eq(200)
    end
  end
end

# Test nested arrays response (key_transformer coverage)
RSpec.describe 'Nested arrays', type: :request do
  describe 'GET /nested_arrays_test' do
    it 'returns nested arrays' do
      get '/nested_arrays_test'
      expect(response.status).to eq(200)
    end
  end
end

# Enum support tests
RSpec.describe 'Enum support', type: :request do
  describe 'simple enum' do
    it 'generates enum for status field', openapi: { enum: { 'status' => %w[active inactive suspended] } } do
      get '/enum_test/status'
      expect(response.status).to eq(200)
    end
  end

  describe 'nested enum' do
    it 'generates enum for nested paths', openapi: {
      enum: {
        'status' => %w[active inactive],
        'user.role' => %w[admin user guest],
      },
    } do
      get '/enum_test/nested'
      expect(response.status).to eq(200)
    end
  end

  describe 'array items enum' do
    it 'generates enum for array item properties', openapi: {
      enum: {
        'items.status' => %w[active inactive],
        'items.priority' => %w[high medium low],
      },
    } do
      get '/enum_test/array_items'
      expect(response.status).to eq(200)
    end
  end

  describe 'request enum' do
    it 'generates enum for request body', openapi: {
      request_enum: { 'action_type' => %w[create update delete] },
      response_enum: { 'status' => %w[pending completed failed] },
    } do
      post '/enum_test', params: { action_type: 'create' }
      expect(response.status).to eq(201)
    end
  end

  describe 'deeply nested enum' do
    it 'generates enum for deeply nested paths', openapi: {
      enum: {
        'organization.settings.visibility' => %w[public private internal],
        'organization.settings.access_level' => %w[standard premium enterprise],
      },
    } do
      get '/enum_test/deeply_nested'
      expect(response.status).to eq(200)
    end
  end

  describe 'enum with symbol keys' do
    it 'supports symbol keys in enum hash', openapi: {
      enum: {
        status: %w[active inactive],
      },
    } do
      get '/enum_test/status'
      expect(response.status).to eq(200)
    end
  end
end
